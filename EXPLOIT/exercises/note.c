#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>  // Added for write() and close() system calls

// Function to display usage information when arguments are missing
void usage(char *prog_name, char *filename) {
    printf("Usage: %s <data to add to %s>\n", prog_name, filename);
    exit(1);  // Changed to exit with error code (1) instead of success (0)
}

void fatal(char *);     // A function for fatal errors
void *ec_malloc(unsigned int);  // An error-checked malloc wrapper

int main(int argc, char *argv[]) {
    int fd;     // File descriptor
    char *buffer;
    char *datafile;

    // Allocate memory with error checking
    buffer = (char*)ec_malloc(100);  // 100 bytes for input + newline + null terminator
    datafile = (char*)ec_malloc(20); // 20 bytes for filename
    strcpy(datafile, "/tmp/notes");  // Set default filename

    if (argc < 2) {                  // If there aren't command line arguments
        usage(argv[0], datafile);    // Display usage message and exit
    }
    
    // Safely copy input to buffer with length checking
    if (strlen(argv[1]) >= 99) {     // 99 to leave room for newline + null
        fatal("in main() input too long (max 98 chars)");
    }
    strncpy(buffer, argv[1], 98);    // Use strncpy instead of strcpy for safety
    buffer[98] = '\0';              // Ensure null termination

    printf("[DEBUG] buffer @ %p: \'%s\'\n", buffer, buffer);
    printf("[DEBUG] datafile @ %p: \'%s\'\n", datafile, datafile);

    // Add newline safely instead of using strncat
    size_t len = strlen(buffer);
    if (len < 99) {                  // Check if there's space for newline
        buffer[len] = '\n';          // Add newline directly
        buffer[len + 1] = '\0';      // Ensure null termination
    } else {
        fatal("in main() buffer too small for newline");
    }

    // Opening file with write-only, create if not exists, and append mode
    fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
    if (fd == -1)
        fatal("in main() while opening file");
    printf("[DEBUG] file descriptor is %d\n", fd);

    // Writing data to file
    if (write(fd, buffer, strlen(buffer)) == -1) {
        close(fd);                   // Clean up file descriptor before fatal exit
        fatal("in main() while writing buffer to file");
    }

    // Closing file
    if (close(fd) == -1)
        fatal("in main() while closing file");

    printf("Note has been saved.\n");
    free(buffer);                    // Free allocated memory
    free(datafile);
    
    return 0;                       // Explicitly return success
}

// A function to display an error message and then exit
void fatal(char *message) {
    char error_message[100];

    strcpy(error_message, "[!!] Fatal Error ");  // Space added for readability
    strncat(error_message, message, 82);         // Adjusted to 82 to account for longer prefix
    perror(error_message);
    exit(-1);
}

// An error-checked malloc() wrapper function
void *ec_malloc(unsigned int size) {
    void *ptr = malloc(size);
    if (ptr == NULL) {
        fatal("in ec_malloc() on memory allocation");
    }
    return ptr;
}