#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include "hacking.h"

#define FILENAME "/var/notes"

// Function prototypes
int print_notes(int, int, char *);     // Note printing function
int find_user_note(int, int);          // Seek in file for a note for user
int search_note(char *, char *);       // Search for keyword function
void fatal(char *);                    // Fatal error handler

int main(int argc, char *argv[]) {
    int userid;
    int printing = 1;
    int fd;         // File descriptor
    char searchstring[100];

    if(argc > 1)                        // If there are command-line arguments
        strcpy(searchstring, argv[1]);  // That is the search string
    else
        searchstring[0] = 0;           // Search string is empty

    userid = getuid();

    fd = open(FILENAME, O_RDONLY);     // Open file for read-only access
    if(fd == -1)
        fatal("in main() while opening file for reading");

    while(printing)
        printing = print_notes(fd, userid, searchstring);

    printf("---------[ end of note data ]------------\n");
    close(fd);
    return 0;
}

// Function to print notes for a given uid that match an optional search string
// Returns 0 at end of file, 1 if there are still more notes
int print_notes(int fd, int uid, char *searchstring) {
    int note_length;
    char byte = 0;
    char note_buffer[100];

    note_length = find_user_note(fd, uid);
    if(note_length == -1)                  // If end of file reached
        return 0;

    read(fd, note_buffer, note_length);    // Read note data
    note_buffer[note_length] = 0;         // Terminate the string

    if(search_note(note_buffer, searchstring))  // If searchstring found
        printf("%s", note_buffer);
    return 1;
}

// Function to find the next note for a given user id
// Returns -1 if end of file reached, otherwise returns length of found note
int find_user_note(int fd, int user_uid) {
    int note_uid = -1;
    unsigned char byte;
    int length;

    while(note_uid != user_uid) {          // Loop until note for user_uid found
        if(read(fd, &note_uid, 4) != 4)    // Read the uid data
            return -1;                    // If 4 bytes aren't read, return EOF
        if(read(fd, &byte, 1) != 1)      // Read the newline separator
            return -1;

        byte = length = 0;
        while(byte != '\n') {            // Figure out bytes to end of line
            if(read(fd, &byte, 1) != 1)  // Read a single byte
                return -1;
            length++;
        }
        lseek(fd, length * -1, SEEK_CUR); // Rewind file reading by length bytes
    }
    printf("[DEBUG] found a %d byte note for user id %d\n", length, note_uid);
    return length;
}

// Function to search a note for a given keyword
// Returns 1 if match found, 0 if no match
int search_note(char *note, char *keyword) {
    int i;
    int keyword_length;
    int match = 0;

    keyword_length = strlen(keyword);
    if(keyword_length == 0)               // If no search string
        return 1;                        // Always match

    for(i = 0; i < strlen(note); i++) {   // Iterate over bytes in note
        if(note[i] == keyword[match])     // If byte matches keyword
            match++;                     // Check for next byte
        else {                           // Otherwise
            if(note[i] == keyword[0])    // If byte matches first keyword byte
                match = 1;              // Start match count at one
            else
                match = 0;             // Reset match count to zero
        }
        if(match == keyword_length)       // If full match found
            return 1;                    // Return matched
    }
    return 0;                           // No match found
}